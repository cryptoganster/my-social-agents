name: Auto Merge PRs

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  check_suite:
    types: [completed]
  status: {}

env:
  # Lista de usuarios autorizados para auto-merge (separados por coma)
  # Actualizar con los usuarios de confianza del equipo
  AUTHORIZED_AUTHORS: 'cryptoganster'

jobs:
  auto-merge:
    name: Auto Merge & Rebase
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Get PR Info
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            let pr;
            if (context.payload.pull_request) {
              pr = context.payload.pull_request;
            } else if (context.payload.check_suite?.pull_requests?.[0]) {
              const prNumber = context.payload.check_suite.pull_requests[0].number;
              const { data } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              pr = data;
            } else {
              core.setOutput('should_merge', 'false');
              return;
            }

            const authorizedAuthors = process.env.AUTHORIZED_AUTHORS.split(',').map(a => a.trim().toLowerCase());
            const prAuthor = pr.user.login.toLowerCase();
            const isAuthorized = authorizedAuthors.includes(prAuthor);

            core.setOutput('pr_number', pr.number);
            core.setOutput('pr_author', pr.user.login);
            core.setOutput('is_authorized', isAuthorized.toString());
            core.setOutput('should_merge', isAuthorized.toString());

            console.log(`PR #${pr.number} by ${pr.user.login}`);
            console.log(`Authorized: ${isAuthorized}`);

      - name: Wait for CI to complete
        if: steps.pr-info.outputs.should_merge == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr-info.outputs.pr_number }};
            const maxAttempts = 60; // 10 minutos m√°ximo
            const delaySeconds = 10;

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              // Verificar si es mergeable
              if (pr.mergeable === null) {
                console.log(`Attempt ${attempt + 1}: Mergeability unknown, waiting...`);
                await new Promise(r => setTimeout(r, delaySeconds * 1000));
                continue;
              }
              
              if (!pr.mergeable) {
                core.setFailed('PR has conflicts and cannot be merged');
                return;
              }
              
              // Verificar status checks
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              const pendingChecks = checks.check_runs.filter(
                c => c.status !== 'completed' && c.name !== 'Auto Merge & Rebase'
              );
              
              if (pendingChecks.length > 0) {
                console.log(`Attempt ${attempt + 1}: ${pendingChecks.length} checks pending...`);
                pendingChecks.forEach(c => console.log(`  - ${c.name}: ${c.status}`));
                await new Promise(r => setTimeout(r, delaySeconds * 1000));
                continue;
              }
              
              // Verificar que todos los checks pasaron
              const failedChecks = checks.check_runs.filter(
                c => c.conclusion === 'failure' && c.name !== 'Auto Merge & Rebase'
              );
              
              if (failedChecks.length > 0) {
                core.setFailed(`${failedChecks.length} checks failed`);
                failedChecks.forEach(c => console.log(`  - ${c.name}: ${c.conclusion}`));
                return;
              }
              
              console.log('All checks passed!');
              return;
            }

            core.setFailed('Timeout waiting for checks to complete');

      - name: Rebase and Merge
        if: steps.pr-info.outputs.should_merge == 'true'
        id: merge
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr-info.outputs.pr_number }};

            try {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              // Use rebase merge method (aligns with rebase strategy)
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'rebase'
              });
              
              console.log(`‚úÖ PR #${prNumber} merged successfully with rebase!`);
              
              // Store branch name for deletion
              core.setOutput('branch_name', pr.head.ref);
              core.setOutput('merge_success', 'true');
            } catch (error) {
              core.setOutput('merge_success', 'false');
              if (error.status === 405) {
                console.log('PR cannot be merged yet (checks pending or conflicts)');
              } else {
                core.setFailed(`Failed to merge: ${error.message}`);
              }
            }

      - name: Delete merged branch
        if: steps.pr-info.outputs.should_merge == 'true' && steps.merge.outputs.merge_success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const branchName = '${{ steps.merge.outputs.branch_name }}';

            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `heads/${branchName}`
              });
              
              console.log(`üóëÔ∏è Branch '${branchName}' deleted successfully!`);
            } catch (error) {
              console.log(`‚ö†Ô∏è Could not delete branch '${branchName}': ${error.message}`);
              // Don't fail the workflow if branch deletion fails
            }

      - name: Skip - Not Authorized
        if: steps.pr-info.outputs.should_merge == 'false' && steps.pr-info.outputs.pr_author != ''
        run: |
          echo "‚è≠Ô∏è Skipping auto-merge for PR by ${{ steps.pr-info.outputs.pr_author }}"
          echo "Only authorized authors can auto-merge: ${{ env.AUTHORIZED_AUTHORS }}"
